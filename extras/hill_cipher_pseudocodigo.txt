Algoritmo 1: Verificación si n > 2
	Input: Número entero n
	Output: Retorna verdadero o falso si n es válido
if n <= 2 then:
	return false
else
	return true
end


Algoritmo 2: Cálculo de factores primos de Zn
	Input: Número entero n
	Output: Retorna lista con números enteros con los factores primos de Zn
list <- 1
for i <- 2 to n do
	if gcd(i, n) == 1 then
		list +<- i
	end
end
return list



Algoritmo 3: Generación de números aleatorios en la matriz K
	Input: Nada
	Output: Retorna una matriz K[2][2] con números aleatorios
for i <- 0 to 2 do
	for j <- 0 to 2 do
		K[i][j] <- random(1, 1e9)
	end
end
return K


Algoritmo 4: Cálculo del determinante en la matriz K
	Input: Matriz K[2][2] y un número entero n con el módulo
	Output: Retorna determinante de la matriz K
det <- (K[0][0] * K[1][1] - K[0][1] * K[1][0]) mod n
return det


Algoritmo 5: Extended Euclidean (Extendido de Euclides)
	Input: Cuatro números enteros a con el determinante de la matriz, 
			b con el valor del módulor, y x1 y y1 como auxiliares
	Output: Retorna el inverso modular
if b == 0 then
	x <- 1
	y <- 0
	return a
end
	(x1, y1) <- (0, 0)
	d <- extended_euclidean(b, a mod b, x1, y1)
	x <- y1
	y <- x1 - y1 * (a div b)
	return d
end

Algoritmo 6: Obtenemos el inverso modular
	Input: Dos números enteros, a el determinante de la matriz y n el módulo
	Output: Retorna un número entero con el inverso modular
x <- 0
y <- 0
g <- extended_euclidean(a, n, x, y)
if g != 1 then
	return ERROR
else
	x <- (x mod n + n) mod n
	return x


Algoritmo 7: Obtenemos K inversa
	Input: Dos números enteros con el inverso modular (detk^(-1)) y el módulo de n
	Output: Matriz k inversa
K_inversa[0][0] <- (K[1][1] * det_inverso) mod n
K_inversa[0][1] <- (-K[0][1] * det_inverso) mod n
K_inversa[1][0] <- (-K[1][0] * det_inverso) mod n
K_inversa[1][1] <- (K[0][0] * det_inverso) mod n
return K_inversa


Algoritmo 8: Key generation for Hill Cipher
	Input: Un número entero n
	Output: Nada
if verificacion(n) then
	list <- factores_primos_zn(n)

	while true do:
		K <- matriz_numeros_aleatorios()
		det <- determinante_k(K)

		if det != factor_primo_Zn then
			continue
		else
			break
	end

	det_inverso <- extended_euclidean(det, n)

	K_inversa <- generacion_k_inversa(det_inverso, K)
	
	return K_inversa

else
	return error
end













